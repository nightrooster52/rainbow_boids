package {	import flash.geom.Point;	public class Obstruction extends Boid {		public var boidArray:Array;		public function Obstruction(master:BoidController, bArray:Array) {			super(master, 0);						this.boidArray = bArray;			cruisingSpeed = 10;			this.personalSpace = Math.random()*50 + 50;			this.sightRange = personalSpace;			this.graphics.clear();			//this.graphics.beginFill(0x00ff00, 1);			this.graphics.beginFill(0xCCCCCC, .3);			graphics.drawCircle(0, 0, personalSpace+8);			this.graphics.beginFill(0x000000, .9);			//this.graphics.beginFill(0x552244, .4);			graphics.drawCircle(0, 0, personalSpace);			this.mass = 2;			this.currentVector.x = Math.random()*0.05 - .1;			this.currentVector.y = Math.random()*0.05 - .1;		}		public override function update():void {						currentSpeed = (cruisingSpeed - currentSpeed)/20;			currentVector = normalizeVector(currentVector,currentSpeed);						this.x += currentVector.x;			this.y += currentVector.y;						for (var i:uint = 0; i < boidArray.length; i++) {				var otherBoid:Boid = boidArray[i];				var currentDistance:Number = cartesianDistance(new Point(this.x,this.y),new Point(otherBoid.x,otherBoid.y));				if (currentDistance < personalSpace+otherBoid.personalSpace  && currentDistance != 0 ) {					var recoil_distance = (personalSpace+otherBoid.personalSpace) - currentDistance;					var nextVector:Point = normalizeVector(new Point(this.x - otherBoid.x, this.y - otherBoid.y), -recoil_distance/2);					otherBoid.currentVector.x += nextVector.x;					otherBoid.currentVector.y += nextVector.y;									}			}						if (this.x < 0 - personalSpace) {				this.x = master.WH.x + personalSpace;			}			if (this.y < 0- this.personalSpace) {				this.y = master.WH.y + personalSpace;			}			if (this.x > master.WH.x + personalSpace) {				this.x = 0 - personalSpace ;			}			if (this.y > master.WH.y + personalSpace) {				this.y = 0 - this.personalSpace ;			}					}	}}